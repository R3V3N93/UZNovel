struct GZNConfig
{
    bool isSetup;
    Vector2 virtualResolution;
    Font font;
    TextureID dialogueBG;
    Vector2 textBox_TopLeft;
    Vector2 textBox_BottomRight;
    int maxLen;
    Vector2 speakerPos;
    double dialogueTextSize;
    double speakerTextSize;
}

struct Stage
{
    Array<Character> characters;
    string speakers;
    double timerCoeff;
    BrokenLines text;
    int curLine;
    double textTimer;
}

Class GZNovelHandler : StaticEventHandler
{
    Stage stage;
    Book curBook;
    int curPage;
    private GZNConfig config;

    Array<Character> characters;
    Array<Book> books;

    private Book _ErrorBook;

    override void OnRegister()
    {
        LoadConfig();
        LoadCharacters("/books/errorbook.json");
        LoadBooks("/books/errorbook.json");

        LoadCharacters("/books/example.json");
        LoadBooks("/books/example.json");
        curPage = -1;
    }

    override void WorldLoaded (WorldEvent e)
    {
        //LoadCharacters("/books/example.json");
        //LoadBooks("/books/example.json");
        StartBookString("Test");
    }

    static GZNovelHandler Get()
    {
        return GZNovelHandler(StaticEventHandler.Find('GZNovelHandler'));
    }
    
    Book FindBook(string what)
    {
        for(int i = 0; i < books.Size(); i++)
        {
            if(books[i].name == what)
                return books[i];
        }
        return null;
    }

    void StartBook(Book what) 
    {
        curBook = what;
        GoNextPage(0);
    }

    void StartBookString(string what)
    {
        StartBook(FindBook(what));
    }

    

    void EndBook() 
    {
        curBook = null;
        curPage = -1;
    }
    clearscope bool IsInBook()
    {
        if(curBook != null && curPage >= 0)
            return true;
        return false;
    }

    

    Character FindCharacter(string codeName)
    {
        for(int i = 0; i < characters.Size(); i++) // I REALLY need to study some algorhithm bullshits to minimize such simple for loop parsing.
        {
            if(characters[i].codeName == codeName)
                return characters[i];
        }
        return null;
    }

    clearscope private Vector2 VirtualRatio()
    {
        int a, b, x, y;
        [a, b, x, y] = Screen.GetViewWindow();
        //console.printf(a.." "..b.." "..x.." "..y);
        return (x / config.virtualResolution.x, y / config.virtualResolution.y); 
    }

    enum PIVOT
    {
        PIVOT_LEFT = 1,
        PIVOT_CENTER = 1<<1,
        PIVOT_RIGHT = 1<<2,
        PIVOT_TOP = 1<<3,
        PIVOT_MIDDLE = 1<<4,
        PIVOT_BOTTOM = 1<<5,
    }

    ui void GZN_DrawImage(TextureID tex, Vector2 pos, int pivot = PIVOT_LEFT|PIVOT_TOP, Vector2 size = (1.0, 1.0), bool highlight = true)
    {
        Vector2 texSize;
        Vector2 realPos;
        [texSize.x, texSize.y] = Texman.GetSize(tex);
        Vector2 ratio = VirtualRatio();
        texSize = (texSize.x * size.x * ratio.x, texSize.y * size.y * ratio.y);

        realPos = (pos.x * config.virtualResolution.x, pos.y * config.virtualResolution.y);

        if(pivot & PIVOT_CENTER)
            realPos.x -= texSize.x / 2.0;
        if(pivot & PIVOT_RIGHT)
            realPos.x -= texSize.x;
        if(pivot & PIVOT_MIDDLE)
            realPos.y -= texSize.y / 2.0;
        if(pivot & PIVOT_BOTTOM)
            realPos.y -= texSize.y;

        Screen.DrawTexture(
            tex: tex,
            animate: true,
            x: realPos.x, 
            y: realPos.y,
            DTA_VirtualWidthF, config.virtualResolution.x,
            DTA_VirtualheightF, config.virtualResolution.y,
            DTA_ScaleX, size.x,
            DTA_ScaleY, size.y,
            DTA_KeepRatio, true,
            DTA_ColorOverlay, (highlight ? 0x00000000 : 0x9B000000)
        );
    }

    ui void GZN_DrawText(string text, Vector2 pos, int line = 0, int pivot = PIVOT_CENTER|PIVOT_MIDDLE, Vector2 size = (1.0, 1.0))
    {
        string localized = StringTable.Localize(text);

        Vector2 textSize = (config.font.StringWidth(text), config.Font.GetHeight());
        Vector2 realPos;
        Vector2 ratio = VirtualRatio();
        //console.printf(""..textSize);
        textSize = (textSize.x * size.x, textSize.y * size.y);
        

        realPos = (pos.x * config.virtualResolution.x, pos.y * config.virtualResolution.y) + (0, textSize.y * line);

        if(pivot & PIVOT_CENTER)
            realPos.x -= textSize.x / 2.0;
        if(pivot & PIVOT_RIGHT)
            realPos.x -= textSize.x;
        if(pivot & PIVOT_MIDDLE)
            realPos.y -= textSize.y / 2.0;
        if(pivot & PIVOT_BOTTOM)
            realPos.y -= textSize.y;

        Screen.DrawText(
            font: config.font,
            normalcolor: Font.CR_UNTRANSLATED,
            x: realPos.x, 
            y: realPos.y,
            text:localized,
            DTA_VirtualWidthF, config.virtualResolution.x,
            DTA_VirtualheightF, config.virtualResolution.y,
            DTA_ScaleX, size.x,
            DTA_ScaleY, size.y,
            DTA_KeepRatio, true
        );
    }

    override void WorldTick()
    {
        config.maxLen = (config.textBox_BottomRight.x - config.textBox_TopLeft.x) * Screen.GetWidth();
        if(IsInBook())
        {
            if(stage.curLine == stage.text.Count())
                return;

            stage.textTimer += stage.timerCoeff;
            if(int(stage.textTimer) > stage.text.StringAt(stage.curLine).Length())
            {
                stage.textTimer = 0.0;
                stage.curLine++;
            }
        }
    }

    override bool InputProcess (InputEvent e)
    {
        if(IsInBook())
        {
            if(InputEvent.Type_KeyDown)
            {
                if(bindings.GetBinding(e.KeyScan) == "+attack")
                {
                    if(stage.curLine < stage.text.Count())
                        stage.curLine = stage.text.Count();
                    else
                        GoNextPage();
                }
            }
        }
        return false;
    }

    override void RenderOverlay (RenderEvent e)
    {
        if(IsInBook())
        {
            if(!config.isSetup)
            {
                Debug.LogWarning("GZNovel is not setup properly! Please check your \cfGZNINFO.json\c- again!");
                return;
            }

            Page curRealPage = curBook.pages[curPage];

            // BG
            GZN_DrawImage(curRealPage.bg, (0.0, 0.0));

            // CG
            if(curRealPage.cg.graphic.IsValid())
            {
                GZN_DrawImage(curRealPage.cg.graphic, curRealPage.cg.pos, size:curRealPage.cg.size);
            }

            // Characters

            for(int i = 0; i < stage.characters.Size(); i++)
            {
                Character curCharacter = stage.characters[i];
                GZN_DrawImage(curCharacter.curGraphic, (curCharacter.pos, 1.0), highlight : curCharacter.IsHighlight);
            }

            // Dialogue box
            GZN_DrawImage(config.dialogueBG, (0.5, 1.0));

            // Speaker
            GZN_DrawText(stage.speakers, config.speakerPos, pivot:PIVOT_CENTER|PIVOT_MIDDLE, size:(config.speakerTextSize, config.speakerTextSize));

            // Dialogue text
            for(int i = 0; i < stage.text.Count(); i++)
            {
                //console.printf(stage.text.StringAt(i).." "..stage.text.Count().." "..stage.curLine);
                if(i > stage.curLine)
                    continue;

                if(i < stage.curLine)
                    GZN_DrawText(stage.text.StringAt(i), (config.textBox_TopLeft + config.textBox_BottomRight) / 2.0, line : i, size:(config.dialogueTextSize, config.dialogueTextSize));
                else
                    GZN_DrawText(stage.text.StringAt(i).Left(int(stage.textTimer)), (config.textBox_TopLeft + config.textBox_BottomRight) / 2.0, line : i, size:(config.dialogueTextSize, config.dialogueTextSize));
            }
        }
    }
}