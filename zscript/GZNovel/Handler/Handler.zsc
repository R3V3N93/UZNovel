struct Stage
{
    Array<Character> characters;
    Array<CG> cg;
    TextureID bg;
    string speakers; // Volatile
    double timerCoeff; // Volatile
    BrokenLines text; // Volatile
    int curLine; // Volatile
    double textTimer; // Volatile
    Vector2 textPos; // Volatile
}

Class GZNovelHandler : StaticEventHandler
{
    Stage stage;
    Book curBook;
    int curPage;
    private GZNConfig config;

    Array<Character> characters;
    Array<Book> books;

    private Book _ErrorBook;

    override void OnRegister()
    {
        LoadConfig();
        LoadCharacters("/books/errorbook.json");
        LoadBooks("/books/errorbook.json");
        curPage = -1;
    }

    override void WorldLoaded (WorldEvent e)
    {
        LoadCharacters("/books/example.json");
        LoadBooks("/books/example.json");
        StartBookString("Test");
        //StartBookString("__ERROR__BOOK__");
    }

    override void WorldUnloaded (WorldEvent e)
    {
        EndBook();
    }

    static GZNovelHandler Get()
    {
        return GZNovelHandler(StaticEventHandler.Find('GZNovelHandler'));
    }
    
    Book FindBook(string what)
    {
        for(int i = 0; i < books.Size(); i++)
        {
            if(books[i].name == what)
                return books[i];
        }
        return null;
    }

    void StartBook(Book what) 
    {
        curBook = what;
        level.SetFrozen(true);
        S_PauseSound(false, true);
        GoNextPage(0);
    }

    void StartBookString(string what)
    {
        StartBook(FindBook(what));
    }

    void EndBook() 
    {
        curBook = null;
        curPage = -1;
        stage.characters.Clear();
        stage.speakers = "";
        stage.timerCoeff = 0.0;
        stage.text = null;
        stage.curLine = 0;
        stage.textTimer = 0;
        stage.cg.Clear();
        S_ResumeSound(false);
        level.SetFrozen(false);
    }

    clearscope bool IsInBook()
    {
        if(curBook != null && curPage >= 0)
            return true;
        return false;
    }

    Character FindCharacter(string codeName)
    {
        for(int i = 0; i < characters.Size(); i++) // I REALLY need to study some algorhithm bullshits to minimize such simple for loop parsing.
        {
            if(characters[i].codeName == codeName)
                return characters[i];
        }
        return null;
    }

    override void WorldTick()
    {
        if(IsInBook())
        {
            if(stage.curLine == stage.text.Count())
                return;

            stage.textTimer += stage.timerCoeff;
            if(int(stage.textTimer) > stage.text.StringAt(stage.curLine).Length())
            {
                stage.textTimer = 0.0;
                stage.curLine++;
            }

            for(int i = 0; i < stage.cg.Size(); i++)
            {
                CG curCG = stage.cg[i];
                double fadeCoeff = 0.0;
                if(curCG.fadeOut > 0.0)
                {
                    if(curCG.alpha <= 0.0)
                    {
                        Debug.LogDebug("CG "..curCG.id.." is gone");
                        stage.cg.Delete(i);
                        continue;
                    }
                    //console.printf(""..curCG.fadeOut);
                    fadeCoeff = -1.0 / (curCG.fadeOut == 0 ? 1.0 : curCG.fadeOut * 1.0);
                }
                else
                    fadeCoeff = 1.0 / (curCG.fadeIn == 0 ? 1.0 : curCG.fadeIn * 1.0);

                //console.printf(""..fadeCoeff.." "..curCG.alpha);

                curCG.alpha += fadeCoeff;
            }
        }
    }

    override bool InputProcess (InputEvent e)
    {
        if(IsInBook())
        {
            if(e.type == e.Type_KeyDown)
            {
                if(bindings.GetBinding(e.KeyScan) == "+attack")
                {
                    Debug.LogDebug("InputProcess.GoNextPage : Proceeding to next page");
                    if(stage.curLine < stage.text.Count())
                        stage.curLine = stage.text.Count();
                    else
                        EventHandler.SendNetworkEvent("GoNextPage");
                }
            }
        }
        return false;
    }

    override void NetworkProcess(ConsoleEvent e)
    {
        Array<String> args;
        e.name.split(args, "|");
        if(args[0] == "GoNextPage")
            GoNextPage();
    }

    override void RenderOverlay (RenderEvent e)
    {
        if(IsInBook())
        {
            if(!config.isSetup)
            {
                Debug.LogWarning("GZNovel is not setup properly! Please check your \cfGZNINFO.json\c- again!");
                return;
            }

            Page curRealPage = curBook.pages[curPage];

            // BG
            GZN_DrawImage(stage.bg, (0.0, 0.0));

            // CG
            for(int i = 0; i < stage.cg.Size(); i++)
            {
                GZN_DrawImage(stage.cg[i].graphic, stage.cg[i].pos, pivot:stage.cg[i].pivot, size:stage.cg[i].size, alpha:stage.cg[i].alpha);
            }

            // Characters
            for(int i = 0; i < stage.characters.Size(); i++)
            {
                Character curCharacter = stage.characters[i];
                GZN_DrawImage(curCharacter.curGraphic, (curCharacter.pos, 1.0), highlight : curCharacter.IsHighlight);
            }

            if(stage.text.Count() > 0) {

            // Dialogue box
            GZN_DrawImage(config.dialogueBG, (0.5, 1.0));

            // Speaker
            GZN_DrawText(stage.speakers, config.speakerPos, pivot:config.speakerPivot, size:(config.speakerTextSize, config.speakerTextSize));

            // Dialogue text
            for(int i = 0; i < stage.text.Count(); i++)
            {
                //console.printf(stage.text.StringAt(i).." "..stage.text.Count().." "..stage.curLine);
                if(i > stage.curLine)
                    continue;

                if(i < stage.curLine)
                    GZN_DrawText(stage.text.StringAt(i), stage.textPos, line : i, pivot:curRealPage.textPivot, size:(config.dialogueTextSize, config.dialogueTextSize));
                else
                    GZN_DrawText(stage.text.StringAt(i).Left(int(stage.textTimer)), stage.textPos, line : i, pivot:curRealPage.textPivot, size:(config.dialogueTextSize, config.dialogueTextSize));
            }
            }
        }
    }
}